%# -*- coding: utf-8-unix -*-

\raggedbottom
\chapter{基础算法与优化思路}
\label{chap:algorithm}

\section{引言}
经典的非交互式差分隐私匿名算法DiffGen是本课题优化算法设计的基础。本章节针对课题相关的技术对DiffGen进行介绍分析，并揭示其缺陷——在较高查询维度的请求中，DiffGen模型的本质和前文论述的频率矩阵加噪模型是一样的。接下来论述针对一维直方图使用的基于一致性约束的优化技术，总结其应用特性同样适用于面向分类应用的范围计数查询需求。这也给频率矩阵模型问题提供了解决方案，并结合DiffGen算法，为接下来的优化算法做铺垫。

\section{DiffGen算法}

DiffGen算法是由Mohammed等人于2011年提出的一个非交互式差分隐私匿名算法\cite{DiffGen}，基于分类树结构和指数机制构建重匿名数据集，其性能优于SuLQ-basedID3和DiffP-C4.5，但仍存在着不足。
本节的示例均基于例\ref{chap3_exmp}的背景，表述如下：
\begin{exmp}
	\label{chap3_exmp}
	某公司有8位应聘者，对“国籍”、“年龄”以及是否被录用统计如表\ref{chap3_table}(a)，类属性为“是否被录用”。
\end{exmp}

\begin{table}[!hpb]
	\label{chap3_table}
	\centering
		\bicaption[tab:firstone]{表}{应聘者统计表}{Table}{The statistical table for candidates}
	\subtable[统计表]{
		\begin{tabular}{|c|c|c|}
			\hline
			$\textbf{国籍}$ & $\textbf{年龄}$ & $\textbf{是否被录用}$ \\
			\hline
			中国 & 18 & 否 \\
			\hline
			蒙古 & 21 & 是 \\
			\hline
			伊朗 & 27 & 否 \\
			\hline
			以色列 & 35 & 否 \\
			\hline
			以色列 & 29 & 是 \\
			\hline
			中国 & 39 & 是 \\
			\hline
			蒙古 & 22 & 否 \\
			\hline
			中国 & 28 & 否 \\
			\hline
		\end{tabular}}
		\qquad
		\subtable[泛化处理后的统计表]{%
			\begin{tabular}{|c|c|c|}
				\hline
				$\textbf{国籍}$ & $\textbf{年龄}$ & $\textbf{类属性计数(录用分布)}$ \\
				\hline
				东亚 & [15-25) & 3 (1是2否) \\
				\hline
				东亚 & [25-40) & 2 (1是1否) \\
				\hline
				西亚 & [15-25) & 0 (0是0否) \\
				\hline
				西亚 & [25-40) & 3 (1是2否) \\
				\hline
			\end{tabular}}
		\end{table}

\subsection{泛化技术}

泛化技术是匿名算法实现的关键技术，在DiffGen中通过匿名树(Taxonomy tree)来组织每个属性的匿名关系。如图\ref{fig:taxonomy}所示，通过指定更一般的泛化域(Dom)，原属性作为叶节点，自底向上地构建匿名树。对于离散属性“国籍”，采取抽象共性的方式进行逐层泛化；对于连续属性“年龄”，通过更大的连续区间进行泛化。表\ref{chap3_table}(b)是泛化处理后的统计结果。
从根节点自顶向下来看，匿名树定义了一套划分规则(Partition guidelines)，指导每个泛化属性如何分裂，如“东亚”的分裂趋势为分成“中国”和“蒙古”。显然匿名树中的属性值是不重复。

\begin{figure}[!htp]
	\centering
	\includegraphics[width=5in]{chap3/taxonomy}
	\bicaption[fig:taxonomy]{图}{属性“国籍”和“年龄”的匿名树}{Fig.}{The taxonomy tree for 'Country' and 'Age'}
\end{figure}


\subsection{算法概述}

DiffGen算法以匿名树作为属性匿名规则，采用决策树构建的方式，在逐步构造分类树的同时对原数据集进行划分，最后发布落在叶节点的数据集。基于例\ref{chap3_exmp}的背景，结合图\ref{fig:diffgen}，DiffGen算法运行过程概括如下：

\begin{figure}[!htp]
	\centering
	\includegraphics[width=6.2in]{chap3/diffgen}
	\bicaption[fig:diffgen]{图}{基于DiffGen算法的数据集发布流程概述}{Fig.}{The release process for dataset based DiffGen}
\end{figure}

\begin{enumerate}
	\label{process}
	\item 定义分类树高限度h。为数据集的每个属性定义匿名树结构，并组合所有匿名树的根节点属性值作为分类树的根节点条目。每个数据集条目根据属性值包含关系，归入相应的节点。例如，由各匿名树根节点属性值构成了图\ref{fig:diffgen}的节点1。对于原数据集条目\{中国，18，否\}，根据各匿名树结构，显然“中国”$\in$“亚洲”，“18”$\in$“[15-40]”，因此它归入节点1。各数据条目与节点的归并关系均如此。
	\item 基于决策树构建算法，通过指数机制选取分裂属性，但与普通决策树算法不同的是，在处理连续属性和使用指数机制时引入噪音干扰以满足差分隐私定义。分裂属性的同时伴随着数据集的划分。例如，图\ref{fig:diffgen}的节点1选出属性“国籍”，根据匿名树划分为“东亚”和“西亚”，于是生成节点2和节点3，同时节点1上的数据条目也归入相应的节点上(通过类计数分布可以看出)。
	\item 重复第二步过程，直到达到迭代上限，即树高h，或者达到某属性匿名树的最“细”划分限度。如图\ref{fig:taxonomy}的椭圆气泡层即为匿名树的划分极限。
	\item 图\ref{fig:diffgen}以中间的粗直线为界，上半部分为完整的分类树，下半部分为本课题归纳的数据发布过程。DiffGen算法往分类树每个叶节点的每一类计数分布上添加拉普拉斯噪音，最后发布统计情况。发布的新数据集如表\ref{chap3_table2}。
\end{enumerate}

\begin{table}[!hpb]
	\label{chap3_table2}
	\centering
	\bicaption[tab:firstone]{表}{DiffGen算法处理后的发布数据集}{Table}{The realesed dataset after DiffGen}
	\subtable[数据项1]{
		\begin{tabular}{|c|c|c|}
			\hline
			$\textbf{国籍}$ & $\textbf{年龄}$ & $\textbf{是否被录用}$ \\
			\hline
			东亚 & [15-25) & 是 \\
			\hline
			东亚 & [15-25) & 是 \\
			\hline
			东亚 & [15-25) & 是 \\
			\hline
			东亚 & [15-25) & 否 \\
			\hline
		\end{tabular}}
		\qquad
		\subtable[数据项2]{%
		\begin{tabular}{|c|c|c|}
			\hline
			$\textbf{国籍}$ & $\textbf{年龄}$ & $\textbf{是否被录用}$ \\
			\hline
			东亚 & [25-40) & 是 \\
			\hline
			东亚 & [25-40) & 是 \\
			\hline
			东亚 & [25-40) & 否 \\
			\hline
			东亚 & [25-40) & 否 \\
			\hline
			东亚 & [25-40) & 否 \\
			\hline
			东亚 & [25-40) & 否 \\
			\hline
		\end{tabular}}
		\qquad
		\subtable[数据项3]{%
		\begin{tabular}{|c|c|c|}
			\hline
			$\textbf{国籍}$ & $\textbf{年龄}$ & $\textbf{是否被录用}$ \\
			\hline
			西亚 & [15-25) & 否 \\
			\hline
		\end{tabular}}
		\qquad
		\subtable[数据项4]{%
		\begin{tabular}{|c|c|c|}
			\hline
			$\textbf{国籍}$ & $\textbf{年龄}$ & $\textbf{是否被录用}$ \\
			\hline
			西亚 & [25-40) & 是 \\
			\hline
		\end{tabular}}
\end{table}


\subsection{算法缺陷探讨}

图\ref{fig:diffgen}的下半部分对流程\ref{process}的第四步进行展开，归纳了DiffGen算法的数据发布过程。根据分类树的构建方法，每个叶节点中的数据项拥有相同的属性值，区别仅在于类计数分布上。组织所有叶节点上的数据项，可以看出这其实就是一个频率矩阵。那么，DiffGen往叶节点的每个类分布加噪的方式其实就等同于往频率矩阵的每个行项加噪。每个叶节点数据集的属性值组合构成了当前叶节点的属性值集合，如节点4的代表的集合为\{东亚，[15-25]\}。很显然，每个叶节点所代表的集合是两两不相交的，例如除了节点4以外必然不存在属性值集合为\{东亚，[15-25]\}的叶节点。可通过简单的反证法证明。
\begin{prop}
 	\label{prop1}
 DiffGen分类树中，每个叶节点的属性值构成的集合是两两不相交的。	
\end{prop}
 
\begin{proof}
  假设命题\ref{prop1}为假，即在DiffGen分类树中，存在两个相交的叶节点，也就是对于某一属性值集合为\{a,b,c\}的叶节点A，存在另一属性值集合为\{a,b,c\}的叶节点B，且A，B不为同一节点。
  	
  根据分类树，寻找A，B的最小公共祖先节点C，得到节点C的分裂属性Ca及Ca的匿名树。由于A与B相交，显然Ca的匿名树在Ca上的划分产生了两个一样的属性值x，x$\in$\{a,b,c\}。具有重复属性值x的结论与匿名树的定义矛盾。因此，命题\ref{prop1}为真。
\end{proof}

命题\ref{prop1}的成立也意味着DiffGen的叶节点集满足差分隐私的水平组合性质\cite{dpcombination}，即叶节点上拉普拉斯噪音的敏感性为一常量，每个叶节点的加噪和应答是相互独立的。例如，在发布数据集上运行决策树分类算法，计算总熵值时需要对全属性分布的计数情况进行累加计算，此时含噪的[数据项1,2,3,4]线性叠加；当计算“东亚”的熵值时，需要[数据项1,2]的线性叠加运算。
可以看到，问题又回到了以行项为单位的独立加噪和处理模式上。因此，在范围查询需求的应用中，DiffGen模型的本质和前文所讨论的频率矩阵加噪模型是一致的，噪音的线性叠加问题制约者发布数据的可用性。


\section{一致性特性}

Michael Hay等人提出了利用一致性约束提升直方图方式(universal histogram)下发布数据的可用性的方法\cite{boosting}。此方法并未减少噪音量，而是通过对噪音分布的求精后置处理，以达到对于任何查询范围的请求均有较准确结果的目的。对于范围计数查询需求而言，该方法完全适用于DiffGen算法，基于此方法本课题设计了优化算法DiffCon。

\subsection{直方图发布方式}

在经典的LP\cite{Dwork Calibrating}方法中，直方图发布方式使用“分箱(Bin)”思想：先将属性值范围切割成若干个箱子，然后将数据集根据属性值放入不同的箱子构成一直方图，最后在每个柱状条(箱子)的计数上添加满足差分隐私的噪音，并发布数据。

如图\ref{fig:histogram}所示，选取表\ref{chap3_table}(a)的“年龄”属性构建直方图，“人数”表示该年龄段参加应聘的总人数。将年龄值范围[15-40]以5为间距切割成5个“箱子”，每条数据根据年龄值归入相应的柱状条中。最后，在每个柱状条上添加拉普拉斯噪音并发布数据。由于柱状条的计数分布是相互独立的，因此噪音的全局敏感性为1。

\begin{figure}[!htp]
	\centering
	\includegraphics[width=5in]{chap3/histogram}
	\bicaption[fig:histogram]{图}{属性“年龄”的直方图显示}{Fig.}{The Histogram of attribute 'Age'}
\end{figure}

\subsection{一致性约束}

差分隐私中的直方图发布方式对于单位长度(Unit length)的查询能提供较好的支持，每个柱状条代表单位长度的计数情况，直接返回即可。但是对于范围查询来说，逐个累加柱状条计数的操作会积累噪音，影响发布数据可用性。这和频率矩阵加噪模型的问题是一样的。

Michael Hay等人通过树壮的辅助结构，利用一致性约束实现对任意范围查询的良好支持。图\ref{fig:consistency}表示的是“年龄”的树状组织结构，标号A,B,C,D,E为原先直方图中的单位柱状条。用$C$表示人数计算，由于年龄范围间的包含关系，可从树结构中得到以下的一致性关系等式：

\begin{eqnarray}
\setcounter{equation}{1}
&{\it{C}}_{15-24} = {\it{C}}_{15-19}+{\it{C}}_{20-24}\\
&{\it{C}}_{25-34} = {\it{C}}_{25-29}+{\it{C}}_{30-34}\\
&\label{3-3}{\it{C}}_{15-34} = {\it{C}}_{15-24}+{\it{C}}_{25-34}\\
&{\it{C}}_{15-40} = {\it{C}}_{15-34}+{\it{C}}_{35-40}
\end{eqnarray}

\begin{figure}[!htp]
	\centering
	\includegraphics[width=5in]{chap3/consistency}
	\bicaption[fig:consistency]{图}{属性“年龄”的树状组织结构}{Fig.}{The tree-organization structure for attribute 'Age'}
\end{figure}

在直方图方式中，通过{\it{\~{C}}} = {\it{C}} + Laplace(1/$\varepsilon$)给每个单位柱状条加噪音，并通过累加操作应答非单位长度的范围查询。如查询年龄为[15-34]，则返回结果({$\widetilde{C}_{A}$}+{$\widetilde{C}_{B}$}+{$\widetilde{C}_{C}$}+{$\widetilde{C}_{D}$})。但是通过等式\ref{3-3}可以看到，若能直接返回{$\widetilde{C}_{15-34}$}，显然能够避免噪音的线性叠加。更具一般性，由于噪音数值的不确定性，我们可以选取min({$\widetilde{C}_{15-34}$},{$\widetilde{C}_{A}$}+{$\widetilde{C}_{B}$}+{$\widetilde{C}_{C}$}+{$\widetilde{C}_{D}$})作为应答返回，这无疑给发布数据提供了提升空间。

Michael Hay等人用往树上的每个节点都加噪的方法替代原先仅在叶节点加噪的方式。但是，这种方法有两个弊端：(1)打破了属性范围间的一致性关系；(2)泄露了内部节点个数、表示范围等信息。因此，Michael Hay等人对树上的噪音分布进行了后置处理，使其在含噪音的情况下再次满足一致性，并且整个过程由于仅是调整噪音因而不违背差分隐私定义。此时，继续用叶节点的累加运算作为范围查询应答的效果，是和选用内部节点一样的。所以，此方案不仅避免了噪音线性叠加，提升了发布数据的可用性，并且可采用仅发布叶节点数据，即直方图发布方式即可，保护了内部节点信息。

\subsection{框架适用性探讨}

根据上一节的论述，本小节对基于一致性约束方案的优化设计思路和DiffGen算法的联系进行以下总结：
\begin{enumerate}
	\item 直方图发布模型和DiffGen的频率矩阵模型属于同一类统计模型——一维属性统计，即计数统计模型。因此，它们遇到了一样的问题：基于单位长度的计数和加噪操作，对于范围计数查询需求而言，存在着噪音线性叠加问题。
	\item Michael 基于泛化技术匿名树构建的DiffGen分类树中，均存在一致性的固有属性。Hay的树状辅助结构和
	改前和改后一致性的作用
	仅发布特节点符合DIffGEn
	
\end{enumerate}
